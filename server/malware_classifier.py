#!/usr/bin/env python3
"""
Malware Type Classifier based on LSTM Behavioral Features
Classifies polymorphic malware type and provides analysis guidance
"""

from typing import Dict, List, Optional, Tuple
from collections import defaultdict


class MalwareTypeClassifier:
    """
    Classifies malware type based on behavioral features detected by LSTM.
    """
    
    # API call groups for different injection techniques
    PROCESS_INJECTION_APIS = {
        'API_CreateRemoteThread',
        'API_WriteProcessMemory',
        'API_ReadProcessMemory',
        'API_NtOpenProcess',
        'API_NtOpenThread',
        'API_NtAllocateVirtualMemory',
        'API_NtProtectVirtualMemory',
        'API_NtCreateThreadEx',
        'API_RtlCreateUserThread',
        'API_NtQueueApcThread',
        'API_NtResumeThread',
        'API_NtSuspendThread',
        'API_NtGetContextThread',
        'API_NtSetContextThread',
    }
    
    DLL_INJECTION_APIS = {
        'API_LdrLoadDll',
        'API_LdrGetProcedureAddress',
        'API_LdrGetDllHandle',
        'API_LdrUnloadDll',
    }
    
    HOOK_INJECTION_APIS = {
        'API_SetWindowsHookExA',
        'API_SetWindowsHookExW',
        'API_UnhookWindowsHookEx',
    }
    
    MEMORY_MANIPULATION_APIS = {
        'API_NtAllocateVirtualMemory',
        'API_NtProtectVirtualMemory',
        'API_NtMapViewOfSection',
        'API_NtUnmapViewOfSection',
        'API_NtFreeVirtualMemory',
    }
    
    ENCRYPTION_APIS = {
        'API_CryptDecrypt',
        'API_CryptEncrypt',
        'API_CryptAcquireContextW',
        'API_CryptAcquireContextA',
        'API_CryptCreateHash',
        'API_CryptHashData',
        'API_CryptGenKey',
        'API_CryptExportKey',
    }
    
    NETWORK_APIS = {
        'API_socket',
        'API_connect',
        'API_bind',
        'API_listen',
        'API_accept',
        'API_send',
        'API_recv',
        'API_WSAStartup',
        'API_WSASocketW',
        'API_WSASocketA',
        'API_WSAConnect',
        'API_WSASend',
        'API_WSARecv',
        'API_InternetOpenA',
        'API_InternetOpenW',
        'API_InternetConnectA',
        'API_InternetConnectW',
        'API_HttpOpenRequestA',
        'API_HttpOpenRequestW',
        'API_HttpSendRequestA',
        'API_HttpSendRequestW',
        'API_InternetReadFile',
        'API_InternetOpenUrlA',
        'API_InternetOpenUrlW',
        'API_gethostbyname',
        'API_getaddrinfo',
        'API_GetAddrInfoW',
        'API_DnsQuery_A',
    }
    
    PERSISTENCE_APIS = {
        'API_RegCreateKeyExA',
        'API_RegCreateKeyExW',
        'API_RegSetValueExA',
        'API_RegSetValueExW',
        'API_RegOpenKeyExA',
        'API_RegOpenKeyExW',
        'API_CreateServiceA',
        'API_OpenServiceA',
        'API_OpenServiceW',
        'API_StartServiceA',
        'API_OpenSCManagerA',
        'API_OpenSCManagerW',
    }
    
    PROCESS_HOLLOWING_APIS = {
        'API_CreateProcessInternalW',
        'API_NtUnmapViewOfSection',
        'API_NtAllocateVirtualMemory',
        'API_WriteProcessMemory',
        'API_NtSetContextThread',
        'API_NtResumeThread',
    }
    
    FILE_OPERATION_INDICATORS = {
        'file_created',
        'file_deleted',
        'file_written',
    }
    
    def classify_malware_type(self, behavioral_features: Dict[str, int]) -> Dict[str, any]:
        """
        Classify malware type based on behavioral features.
        
        Args:
            behavioral_features: Dictionary of behavioral features (API calls, file ops, etc.)
            
        Returns:
            Dictionary with classification results
        """
        # Count API calls by category
        api_counts = defaultdict(int)
        for api, count in behavioral_features.items():
            if api.startswith('API_'):
                api_counts[api] = count
        
        # Calculate scores for each malware type
        scores = {
            'process_injection': self._calculate_injection_score(api_counts, self.PROCESS_INJECTION_APIS),
            'dll_injection': self._calculate_injection_score(api_counts, self.DLL_INJECTION_APIS),
            'hook_injection': self._calculate_injection_score(api_counts, self.HOOK_INJECTION_APIS),
            'process_hollowing': self._calculate_injection_score(api_counts, self.PROCESS_HOLLOWING_APIS),
            'encrypted_payload': self._calculate_injection_score(api_counts, self.ENCRYPTION_APIS),
            'network_activity': self._calculate_injection_score(api_counts, self.NETWORK_APIS),
            'persistence': self._calculate_injection_score(api_counts, self.PERSISTENCE_APIS),
        }
        
        # Determine primary type
        primary_type = max(scores.items(), key=lambda x: x[1])
        
        # Get detected techniques
        detected_techniques = [
            technique for technique, score in scores.items() 
            if score > 0.3  # Threshold for detection
        ]
        
        # Classify overall type
        malware_type = self._determine_malware_type(scores, detected_techniques)
        
        # Get top suspicious APIs
        top_apis = self._get_top_suspicious_apis(api_counts)
        
        # Get analysis guidance
        analysis_guidance = self._generate_analysis_guidance(malware_type, detected_techniques, top_apis, behavioral_features)
        
        # Get remediation steps
        remediation_steps = self._generate_remediation_steps(malware_type, detected_techniques)
        
        return {
            'malware_type': malware_type,
            'primary_type': primary_type[0],
            'primary_type_confidence': primary_type[1],
            'detected_techniques': detected_techniques,
            'technique_scores': scores,
            'top_suspicious_apis': top_apis,
            'analysis_guidance': analysis_guidance,
            'remediation_steps': remediation_steps,
        }
    
    def _calculate_injection_score(self, api_counts: Dict[str, int], api_set: set) -> float:
        """Calculate injection score based on API calls."""
        total_calls = sum(api_counts.get(api, 0) for api in api_set)
        unique_apis = sum(1 for api in api_set if api_counts.get(api, 0) > 0)
        
        # Score based on total calls and unique APIs
        if total_calls == 0:
            return 0.0
        
        # Normalize score (0-1)
        call_score = min(total_calls / 50.0, 1.0)  # Cap at 50 calls
        api_score = min(unique_apis / len(api_set), 1.0)
        
        return (call_score * 0.7 + api_score * 0.3)
    
    def _determine_malware_type(self, scores: Dict[str, float], techniques: List[str]) -> str:
        """Determine overall malware type."""
        if 'process_injection' in techniques and scores['process_injection'] > 0.5:
            if 'process_hollowing' in techniques:
                return "Process Hollowing Malware"
            elif 'dll_injection' in techniques:
                return "DLL Injection Malware"
            else:
                return "Process Injection Malware"
        elif 'dll_injection' in techniques and scores['dll_injection'] > 0.5:
            return "DLL Injection Malware"
        elif 'hook_injection' in techniques and scores['hook_injection'] > 0.5:
            return "Hook Injection Malware"
        elif 'encrypted_payload' in techniques and scores['encrypted_payload'] > 0.5:
            if 'network_activity' in techniques:
                return "Encrypted C2 Malware"
            else:
                return "Encrypted Payload Malware"
        elif 'network_activity' in techniques and scores['network_activity'] > 0.5:
            if 'persistence' in techniques:
                return "Advanced Persistent Threat (APT)"
            else:
                return "Network-Based Malware"
        elif 'persistence' in techniques:
            return "Persistence Malware"
        elif len(techniques) > 2:
            return "Multi-Technique Polymorphic Malware"
        else:
            return "Polymorphic Malware"
    
    def _get_top_suspicious_apis(self, api_counts: Dict[str, int], top_n: int = 10) -> List[Tuple[str, int]]:
        """Get top N most suspicious API calls."""
        # Filter out zero counts and sort
        suspicious = [(api, count) for api, count in api_counts.items() if count > 0]
        suspicious.sort(key=lambda x: x[1], reverse=True)
        return suspicious[:top_n]
    
    def _generate_analysis_guidance(
        self, 
        malware_type: str, 
        techniques: List[str], 
        top_apis: List[Tuple[str, int]],
        features: Dict[str, int]
    ) -> Dict[str, any]:
        """Generate analysis guidance based on detected features."""
        guidance = {
            'severity': 'HIGH',
            'summary': '',
            'key_indicators': [],
            'behavioral_patterns': [],
            'recommended_analysis': [],
        }
        
        # Determine severity
        if 'process_injection' in techniques or 'process_hollowing' in techniques:
            guidance['severity'] = 'CRITICAL'
        elif 'network_activity' in techniques and 'persistence' in techniques:
            guidance['severity'] = 'CRITICAL'
        elif len(techniques) >= 3:
            guidance['severity'] = 'HIGH'
        
        # Generate summary
        guidance['summary'] = f"Detected {malware_type.lower()} with {len(techniques)} injection/evasion techniques."
        
        # Key indicators
        if 'process_injection' in techniques:
            guidance['key_indicators'].append("Process injection detected - malware injects code into legitimate processes")
        if 'dll_injection' in techniques:
            guidance['key_indicators'].append("DLL injection detected - malicious DLLs loaded into processes")
        if 'encrypted_payload' in techniques:
            guidance['key_indicators'].append("Encrypted payload detected - code is encrypted/obfuscated")
        if 'network_activity' in techniques:
            guidance['key_indicators'].append("Network activity detected - potential C2 communication")
        if 'persistence' in techniques:
            guidance['key_indicators'].append("Persistence mechanisms detected - malware installs for long-term access")
        
        # Behavioral patterns
        if top_apis:
            guidance['behavioral_patterns'].append(f"Top suspicious API: {top_apis[0][0]} (called {top_apis[0][1]} times)")
        
        # Check for specific patterns
        if features.get('API_CreateRemoteThread', 0) > 0:
            guidance['behavioral_patterns'].append("CreateRemoteThread detected - classic process injection technique")
        if features.get('API_WriteProcessMemory', 0) > 5:
            guidance['behavioral_patterns'].append("Multiple WriteProcessMemory calls - writing payload to process memory")
        if features.get('API_NtProtectVirtualMemory', 0) > 0:
            guidance['behavioral_patterns'].append("Memory protection changes - making injected code executable")
        if features.get('resolves_host', 0) > 0:
            guidance['behavioral_patterns'].append("DNS resolution detected - connecting to external servers")
        if features.get('file_created', 0) > 3:
            guidance['behavioral_patterns'].append("Multiple files created - dropping additional payloads")
        
        # Recommended analysis
        guidance['recommended_analysis'] = [
            "Analyze process tree to identify injected processes",
            "Check network connections for C2 communication",
            "Examine registry keys for persistence mechanisms",
            "Review file system for dropped files",
            "Analyze memory dumps of suspicious processes",
        ]
        
        if 'network_activity' in techniques:
            guidance['recommended_analysis'].append("Capture and analyze network traffic")
        if 'encrypted_payload' in techniques:
            guidance['recommended_analysis'].append("Extract and decrypt payload from memory")
        
        return guidance
    
    def _generate_remediation_steps(self, malware_type: str, techniques: List[str]) -> List[Dict[str, str]]:
        """Generate remediation steps for users."""
        steps = []
        
        # Immediate actions
        steps.append({
            'step': 1,
            'action': 'IMMEDIATE: Disconnect from network',
            'description': 'Disconnect your device from the internet immediately to prevent C2 communication and data exfiltration.',
            'priority': 'CRITICAL'
        })
        
        steps.append({
            'step': 2,
            'action': 'IMMEDIATE: Terminate suspicious processes',
            'description': 'Open Task Manager (Ctrl+Shift+Esc) and end any suspicious processes. Look for processes with unusual names or high CPU/memory usage.',
            'priority': 'CRITICAL'
        })
        
        # Process injection specific
        if 'process_injection' in techniques or 'process_hollowing' in techniques:
            steps.append({
                'step': 3,
                'action': 'Check for process injection',
                'description': 'Use Process Explorer or Process Hacker to identify processes with injected code. Look for processes with unusual DLLs or memory regions.',
                'priority': 'HIGH'
            })
            
            steps.append({
                'step': 4,
                'action': 'Kill injected processes',
                'description': 'Terminate any processes that show signs of injection. Be careful not to kill critical system processes.',
                'priority': 'HIGH'
            })
        
        # DLL injection specific
        if 'dll_injection' in techniques:
            steps.append({
                'step': 5,
                'action': 'Remove malicious DLLs',
                'description': 'Scan for and remove malicious DLL files. Check common locations: %SystemRoot%\\System32, %AppData%, %Temp%.',
                'priority': 'HIGH'
            })
        
        # Network activity
        if 'network_activity' in techniques:
            steps.append({
                'step': 6,
                'action': 'Block network connections',
                'description': 'Use Windows Firewall to block all outbound connections from suspicious processes. Check network connections in Task Manager.',
                'priority': 'HIGH'
            })
            
            steps.append({
                'step': 7,
                'action': 'Check for data exfiltration',
                'description': 'Review network logs and check if any sensitive data was transmitted. Monitor for unusual outbound traffic.',
                'priority': 'MEDIUM'
            })
        
        # Persistence mechanisms
        if 'persistence' in techniques:
            steps.append({
                'step': 8,
                'action': 'Remove persistence mechanisms',
                'description': 'Check and remove registry keys in HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run and HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run. Also check Windows Services and Scheduled Tasks.',
                'priority': 'HIGH'
            })
        
        # General cleanup
        steps.append({
            'step': 9,
            'action': 'Run full antivirus scan',
            'description': 'Perform a full system scan with updated antivirus software. Use Windows Defender or a reputable third-party antivirus.',
            'priority': 'HIGH'
        })
        
        steps.append({
            'step': 10,
            'action': 'Clean temporary files',
            'description': 'Delete temporary files from %Temp%, %AppData%\\Local\\Temp, and browser cache directories.',
            'priority': 'MEDIUM'
        })
        
        steps.append({
            'step': 11,
            'action': 'Change all passwords',
            'description': 'Change passwords for all accounts that were accessed on this device, especially banking, email, and social media accounts.',
            'priority': 'HIGH'
        })
        
        steps.append({
            'step': 12,
            'action': 'Monitor for suspicious activity',
            'description': 'Continue monitoring system for 2-4 weeks. Check for unusual network activity, new processes, or file modifications.',
            'priority': 'MEDIUM'
        })
        
        # Recovery options
        steps.append({
            'step': 13,
            'action': 'Consider system restore or reimage',
            'description': 'If the infection is severe, consider restoring from a clean backup or performing a clean Windows installation.',
            'priority': 'MEDIUM'
        })
        
        steps.append({
            'step': 14,
            'action': 'Report the incident',
            'description': 'Report the malware incident to your IT department or security team. If this is a personal device, consider reporting to relevant authorities.',
            'priority': 'LOW'
        })
        
        return steps

